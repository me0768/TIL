# REALMYSQL_3장 아키텍처

생성일: 2021년 6월 03일 오전 12:02

## 전체 구조

<img src=".\REALMYSQL_3장 아키텍처 cd0d93e8267a4847a6a54fa612292782\Untitled.png" style="zoom:80%;" />

- MYSQL엔진: 커넥션 핸들러, SQL파서, 전처리기, 옵티마이저 등
- 스토리지 엔진: SQL문장을 분석하거나 최적화. 실제 데이터를 디스크 스토리지에 저장하거나 읽어옴.
    - 스토리지 엔진은 여러개를 동시에 사용할 수 있다. 테이블 당 지정 가능(!)
- MYSQL엔진→ 스토리지 엔진으로 쓰기 읽기 요청 시 사용되는 **핸들러** API

### 스레딩 구조

mysql서버는 스레드 기반으로 작동한다.

- foreground thread (클라이언트 쓰레드)
    - 최소 mysql에 접속된 클라이언트 수만큼 존재.
    - 클라이언트가 요청한 쿼리문장을 처리
    - 커넥션 종료하면 다시 스레드 캐시(thread pool)로 돌아감. (쓰레드 풀에 있는 대기중인 쓰레드 수가 thread_cache_size 이하일때만)
    - 데이터를 데이터 버퍼, 캐시로부터 가져오고 없으면 디스크의 데이터나 인덱스파일로부터 데이터를 읽어온다.
        - MyISAM: 디스크 쓰기 작업까지 처리
        - InnoDB: 데이터 버퍼나 캐시까지만 foreground 쓰레드가 처리, 나머지 버퍼~ 디스크는 백그라운드가 처리
- background thread
    - InnoDB인 경우, 여러 작업이 백그라운드로 처리됨
    - 대표적으로 log thread
    - write thread
        - 읽기 쓰레드는 많은 작업을 백그라운드에서 처리하므로, 일반적인 내장 디스크에서는 2~4, DAS, SAN 등 스토리지는 4개 이상으로 충분히 설정.
            - *DAS, SAN : 복수의 디스크를 논리적으로 묶어서 사용(단일 디스크로 모자랄 때)하는 스토리지 시스템 - lan으로 연결된게  NAS*
    - 읽기 작업은 절대 지연 x.
    - 쓰기 작업은 InnoDB는 버퍼링 해서 일괄 처리. (MyISAM은 x)

### 메모리 사용 구조

- **글로벌 메모리 영역**
    - 버퍼 풀, 쿼리 캐시, 로그 버퍼 등
    - 쓰레드 수와 무관하게 거의 하나의 메모리 공간만. 모든 스레드가 공유.
- **로컬 메모리 영역**
    - = 세션 메모리 영역
    - 커넥션 버퍼, 정렬 버퍼, result 버퍼 등
    - 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역.

### 쿼리가 실행되는 과정

**sql파서 → 전처리기 → sql 옵티마이저 → sql실행기 → 데이터 읽기/쓰기 (이것만 스토리지 엔진에서 처리) → 디스크 스토리지**

- parser: 쿼리를 토큰으로 분리해 트리 구조로 만들어냄. 기본 문법 오류 발견
- 전처리기: 각 토큰을 테이블 이름/컬럼 이름/내장함수 와 매핑해 해당 객체의 존재여부, 권한 등을 확인.
- 옵티마이저: dbms의 두뇌..라고 한다. 쿼리문장을 저렴한 비용으로 가장 빠르게 처리할지 결정.
- 실행엔진: 옵티마이저에서 만들어진 계획대로 핸들러에게 요청해서 받은 결과를 또 다른 핸들러 요청으로 연결하는 역할.

### 복제(replication)

- 2대 이상의 mysql서버가 동일한 데이터를 담도록 실시간으로 동기화하는 기술.
  - 왜 필요한가?
    - 데이터가 갈수록 대용량화되므로 확장성이 중요. 확장성을 위한 다양한 기술 중 하나.
    - 
- master db에 모든 쿼리, slave db에 select쿼리를. slave는 읽기만 가능. 역할로 구분.
  - 일반적으로 마스터는 반드시 1개, 슬레이브는 1개 이상.
  - master:  바이너리 로그가 활성화되면 마스터가 될 수 있다.
    - 데이터 구조나 내용을 변경하는 쿼리는 바이너리 로그에 기록된다.
    - slave가 변경 내역을 요청하면 master는 그 바이너리 로그를 읽어 slave로 넘김. (Binlog dump 라는쓰레드가 전담함)
  - slave: 바이너리로그를 받아올 마스터 장비의 정보(ip주소, 포트, 접속계정)를 가지고 있으면 슬레이브가 된다. slave가 되기위한 별도 옵션 필요 없음.
    - slave는 릴레이 로그를 가지고 있다.
    - 읽기 전용으로 설정함(read_only 설정 파라미터 in my.cnf) - slave를 변경해버리는 실수를 막기 위해서.
    - slave 서버의 io쓰레드는 마스터 서버에 접속해 변경 내역을 요청하고, 받아온 변경 내역을 릴레이 로그에 기록함. → slave의 sql쓰레드가 릴레이 로그에 기록된 변경 내역을 재실행함으로써 slave의 데이터를 마스터와 동일한 상태로 데이터 파일로 저장.
- 복제에 대해  주의할점
  - 슬레이브는 하나의 마스터만 설정 가능
  - 슬레이브 서버 장비는 마스터와 동일한 사양이 적합하다.
    - 마스터 서버에서 수많은 동시 사용자가 실행한 변경 쿼리가 슬레이브 서버에서는 하나의 스레드로 모두 처리되어야 한다. → 변경이 잦으면 슬레이브 서버의 사양이 좋아야 지연 없이 하나의 스레드로 처리 가능.
    - 데이터 조회보다 데이터 변경은 1/10 이하 수준으로 유지되는게 일반적이어서 + 마스터가 다운된 경우 복구 대안으로 사용되기도 해서 사양을 동일하게 맞추는게 대부분임
- 복제가 불필요한 경우에는 바이너리 로그를 중지하자.
  - 바이너리 로그 작성을 위해 많은 자원을 소모한다.
    - 안정적으로 기록하기 위해 gap lock 유지, 매번 트랜잭션 커밋때마다 기록함.

*** 스프링에서 부하 분산을 위해 read는 slave에 요청할 수 있도록 datasource routing 할 수 있다.

https://velog.io/@kingcjy/Spring-Boot-JPA-DB-Replication-설정하기

https://d2.naver.com/helloworld/5812258

(해보고 다시 기록 남길것)

### 쿼리 캐시

쿼리의 결과를 캐시해두는 기능이다.

- 쿼리캐시 비교 검색 과정
    1. 모든 처리보다 가장 앞단에서 캐시된 결과가 있는지 유무를 비교
        - 공백, 탭, 대소문자까지 다 동일해야 같은 쿼리로 인식. - 쿼리가 달라지지 않게 쿼리를 관리할 필요가 있다
    2. 사용자가 결과를 볼 권한이 있는가
    3. 트랜잭션 내 실행된 쿼리인 경우 가시 범위 내에 있는 결과인가
    4. 호출 시점에 따라 결과가 달라지는 요소가 있는가? - sysdate(), rand() , date()
    5. 캐시가 만들어진 후 데이터가 다른 사용자에 의해 변경되지 않았는가
        - 캐시에 있는 데이터가 변경되면 invalidate되어야함.  (table단위로, 어떤 테이블에 insert 등 변경이 일어나면)  - 쿼리 캐시 용량을 너무 크게 설정하면 한번에 캐시 삭제 작업이 엄청 클 수 있음. - 쿼리 캐시의 적절한 크기는 32~64MB

    6. 쿼리에 의해 만들어진 결과가 캐시하기에 너무 크지 않은가

    - query_cache_limit 설정으로 특정 크기 미만의 결과만 캐시할 수 있다.
    - 결과를 만들어내는 데까지 시간은 오래걸리고 group by, distinct, count 등 집합함수 결과가 캐시 사용하면 매우 효율적.
- 쿼리 캐시가 얼마나 사용됐는지 확인

    `show global status like 'Qcache%'`

    `show global status like 'Com_select';`

    쿼리 캐시 히트율 = Qcache_hits / (Qcache_hits + Com_select) * 100

    - 히트율이 높을수록  캐시를 사용하는게 좋지만, 1%의 히트율이라도 해당 쿼리가 사용하는 자원이 크다면 캐시가 가치 있다.

## InnoDB 구조

### InnoDB 특성

- PK에 의한 클러스터링
    - **pk값의 순서대로 디스크에 저장된다! → pk에 의한 range scan은 상당히 빠름. 실행 계획에서도 다른 인덱스에 비해 키가 선택될 확률이 높음.**
- 잠금이 필요없는 일관된 읽기
    - MVCC기술로 락을 걸지 않고 읽기 작업 수행. 읽기 작업은 다른 트랜잭션의 락을 기다리지 않고 읽을 수 있음
- 외래 키 지원
    - 외래키는 부모, 자식테이블 모두 해당 칼럼에 인덱스생성 필요, 변경 시에는 두개의 테이블 모두 데이터가 있는지 체크해야하므로 잠금이 여러 테이블로 전파, 데드락 발생이 많아짐.  (??)
- 자동 데드락 감지
    - 데드락 발생과 동시에 감지되어 감지된 데드락은 트랜잭션 중 rollback이 가장 용이한 것을 자동으로 강제종료함.
- 자동화된 장애 복구

<img src=".\REALMYSQL_3장 아키텍처 cd0d93e8267a4847a6a54fa612292782\Untitled 1.png" style="zoom:80%;" />

책이랑 그림이 조금 다르다... 

### InnoDB 버퍼 풀

- 핵심!
- 디스크의 데이터 파일, 인덱스 정보 메모리에 캐시해두는 공간.
- 쓰기 작업을 지연시켜 일괄작업으로 처리할 수 있게 해주는 버퍼 역할도 함.
    - 모아서 처리 → 랜덤한 디스크작업 횟수 줄임
    - 아직 디스크에 기록되지 않은 변경된 데이터 : dirty page
    - 주기적 또는 조건에 따라 체크포인트 이벤트 발생하면 write 스레드가 필요한 만큼의 더티 페이지만 디스크로 기록.
- 이 외에도 많은 백그라운드 작업의 기반.
- 사이즈는 전체 메모리의 50~80%로 os와 각 클라이언트 쓰레드가 사용할 메모리 고려해서 정하라
- 설정 가능한 파라미터들 : [http://cloudrain21.com/mysql-innodb-basic-performance-tunning](http://cloudrain21.com/mysql-innodb-basic-performance-tunning)

### Undo 로그

- update, delete로 데이터 변경 시 변경 전의 데이터를 보관하는 곳
- 목적: 트랜잭션의 롤백 대비 + 트랜잭션 격리 수준 유지에 사용

### Insert Buffer

- db에 변경이 일어나면 인덱스도 업데이트가 이루어져야하는데.. 자원 소모가 심하므로, 변경해야할 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트, 디스크로 읽어와야한다면 실행 안하고 임시 저장해두고 사용자에게 결과를 반환.  이 때 쓰는 임시 공간이다.
- 유니크인덱스는 인서트 버퍼를 사용할 수 없다.

### Redo로그 및 로그 버퍼

- 변경된 데이터에 대해 버퍼 풀 같은 장치만으로는 ACID를 보장할 수 없음. 순차적으로 디스크에 기록할 수 있도록 하기 위해 redo 로그가 있다.
- redo로그도 너무 많으면 기록작업도 문제가 될 수 있어서 최대한 acid보장하는 수준에서 버퍼링 하도록 로그 버퍼링에 사용되는 공간이 로그 버퍼.

### MVCC(multi version concurrency control)

- 가장 큰 목적은 잠금을 사용하지 않는 일관된 읽기. undo로그를 이용해 구현함.
- 멀티버전: 하나의 레코드에 대해 여러개의 버전이 동시에 관리된다.
- update 하나 실행 후 아직 commit되지 않은 상태에서 다른 사용자가 select를 하면, 버퍼풀에 있는 데이터를 반환할까, undo로그 에 있는 데이터를 반환할까?
    - ⇒ 격리수준에 따라 다름.
        - read_uncommitted는 변경된 상태의 데이터를 반환함
        - read_committed 이상의 격리수준인 경우 변경되기 이전인 undo 영역의  데이터를 반환한다.

### InnoDB와 MyISAM 비교

- mysql 5.5부터 innodb가 기본 스토리지 엔진.
- MyISAM은 인덱스를 위한 키 캐시의 데이터를 os의 캐시에 의존 / innoDB는 자체 버퍼풀
- 트랜잭션 관리, 동시성, 성능 다 innodb가 더 좋음.

## 로그파일

디버깅할때 db로그파일을 찾아보자

- 에러로그 파일 - configuration파일에서 `log_error`
- 실행되는 쿼리 전부 로그로 보고싶다면 쿼리 로그를 활성화 해서 로그 파일로 기록하게 할 수 있다. → general log
- 성능저하 검사, 정기적인 점검을 위한 튜닝 시 어떤 쿼리가 문제의 쿼리인지를 알려면 slow query log를 보기.
    - configuration에 정의한 시간 이상의 시간이 소요된 쿼리가 모두 기록됨.
