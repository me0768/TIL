## 디스크 읽기방식

### 디스크

- 내장 디스크
- DAS(Direct Attached Storage) : 내장디스크의 용량문제를 해결. 컴퓨터 본체에 연결해서 사용.
- NAS(Network Attached Storage): 여러 컴퓨터에서 공유해서 사용할 수 있음. 컴퓨터 본체에 직접연결x, TCP/IP를 통해 연결됨. 속도는 더 느림.
- SAN(Storage Area Network): DAS로 안되는 더 대용량의 스토리지 공간 제공. 여러 컴퓨터 동시 사용o. 컴퓨터 본체와 광케이블로 연결.
- 디스크 드라이브 : CPU, 메모리는 전자식인데 반해 기계식임. 그래서 병목이 됨
- SSD(solid state drive) : 전자식 저장 매체. 기존과 똑같은 인터페이스(SATA, SAS)지원하여 내장 디스크, DAS, SAN에 그대로 사용 가능.
  - 기존 디스크 드라이브의 저장용 플래터(원판) 없앰. 플래시 메모리 장착.
  - 랜덤 I/O가 훨씬 빠르다. → DBMS용 스토리지에 최적.

### 랜덤 I/O와 순차 I/O

- 둘 다 디스크 드라이브의 플래터(원판)을 돌려서 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽음.
- 순차I/O 는 순차적으로 읽기 때문에 처음 한번만 디스크 헤더를 움직이면 됨
- 랜덤I/O는 기록할 위치를 찾기 위해 3개의 페이지 기록이면 디스크 헤더를 3번 움직이고 3번 시스템콜 요청이 감..→ 이것때문에 시간이 더 걸림
  - 쿼리 튜닝: 랜덤 I/O 자체를 줄이는 일. mysql서버 자체적으로는 이걸 줄이기 위해 그룹커밋, 바이너리 로그버퍼, innoDB로그버퍼 등 내장

## 인덱스란?

- 책 마지막의 '찾아보기' 기능에 비유.
  - key: 컬럼의 값, value: 레코드의 주소
  - 책 색인도 ㄱㄴㄷ 순인것처럼 인덱스도 주어진 순서대로 정렬된다는 것도 중요한 특징.
- 컬럼의 값을 항상 정렬된 상태로 유지하고, 데이터 파일 자체는 별도 정렬 없음.
  - → 저장 과정(insert, update, delete)이 느린 대신 빠르게 read. 신중하게 선택하자.
- 역할별 인덱스 종류
  - Primary key
  - Secondary key(보조키)
    - pk를 제외하고 다 보조인덱스임.
- 데이터 저장방식(알고리즘) 별 인덱스 종류
  - b-tree
  - hash: 컬럼의 값으로 해시값을 계산해서 인덱싱. 매우빠른 검색. 대신 prefix일치 등 일부만 검색할 때는 사용 못함 - 메모리 기반 db에서 많이 사용.
  - fractal-tree
  - ..
- 중복 허용 여부로 분류되는 인덱스
  - unique index : 옵티마이저가 1건의 레코드만 찾으면 더이상 찾지 않아도 된다
  - non-unique index

## B-Tree 인덱스

B means 'Balanced' !

### 구조 및 특성

- root : 최상위
- branch: root 와 leaf 사이. 자식노드 주소를 갖고있다.
- leaf: 실제 데이터 레코드 주소값은 leaf만 가지고 있다.
- innoDB테이블에서는 PK에 의해 클러스터링 됨 → PK 값 자체가 주소 역할을 함.
- 인덱스 레코드 = 인덱스 컬럼 값 + 주소 값(PK값)

### B-Tree 인덱스 키 추가 및 삭제

- 인덱스 키 추가
  - b-tree상의 적절한 위치 검색 → 레코드의 키값과 대상 레코드의 주소정보를 leaf노드에 저장. → leaf노드가 꽉차서 더 저장할 수 없으면 leaf노드가 split되어야함(이것때문에 insert가 비용이 많이 듬)
  - 인덱스 추가로 인한 비용은 디스크로부터 인덱스 페이지를 읽고쓰기를 해야하기 때문에 시간이 오래 걸리는 것임.
  - (작업 비용 추산 내용은 아직 이해를 못함 ㅠ)
  - innodb는 상황에 따라 적절하게 insert문 실행 뒤에 추가작업을 지연시키거나 바로처리하거나 함.
    - 과정
      1. 사용자의 insert쿼리 실행
      2. innoDB의 **버퍼풀**에 새로운 키값을 추가해야할 페이지(B-Tree의 리프노드) 가 존재한다면 즉시 키 추가
      3. 없다면 **인서트 버퍼**에 추가할 키 값과 레코드의 주소를 임시로 기록. 쿼리 실행 완료
      4. 백그라운드에서 인덱스 페이지를 읽을 때마다 인서트 버퍼에 머지해야할 인덱스 키값이 있는지 확인. 있다면 머지 (머지: B-Tree에 인덱스 키와 주소 저장)
      5. db 서버 자원의 여유가 있을 때 인서트 버퍼 머지 쓰레드가 조금씩 인서트 버퍼에 임시 저장된 인덱스 키와 주소값을 머지
    - mysql 5.5부터 인서트 버퍼 → Change buffering으로 이름 변경. (DELETE도 지연처리 가능하기 때문)
- 인덱스 키 삭제
  - B-Tree의 리프노드를 찾아서 삭제 마크만 하면 작업 완료.
    - 마킹 작업도 디스크 I/O (쓰기)
- 인덱스 키 변경
  - 삭제 후 추가로 처리됨
    - 인덱스 키 값은 값에 따라 리프노드 위치가 결정되므로
- 인덱스 키 검색
  - 루트→브랜치→리프 순으로 비교하며 찾는다.
  - B-tree인덱스는 exact 또는 prefix검색만 가능하다. (<>나 suffix는 안됨)
  - 키 값에 변형이 가해진 후(함수, 연산 수행) 비교되면 인덱스를 못탐. 인덱스는 원형으로 저장되어있는데 변형해버리면 찾고자하는게 없을 것이기 때문.
  - InnoDB에서는 레코드 잠금 or 넥스트 키 락(갭 락)이 검색을 수행한 인덱스를 잠근 후에 테이블 레코드를 잠그는 방식임. UPDATE, DELETE 실행 시 인덱스가 없으면 불필요하게 많은 레코드가 잠기고 테이블의 모든 레코드가 잠기기도 함. → 설계 잘하자

### B-Tree인덱스 사용에 영향을 미치는 요소

1. 인덱스 키값의 크기

   - 디스크에 데이터를 저장하고 읽고, 버퍼 풀에서 버퍼링하고, 인덱스가 관리되는 가장 기본 단위: Page 또는 블록이라 함.
     - B-Tree에서 노드 구분도 기준이 page임
   - B-Tree는 이진트리가 아님. 자식노드 개수가 가변적임.
     - 자식 노드를 몇개까지?
       - ⇒ 인덱스의 페이지 크기와 키 값의 크기에 따라 결정됨
       - innoDB 모든 페이지의 크기는 16kb
       - 한 페이지당 키가 16바이트, 자식노드 주소가 12바이트라면, 하나의 인덱스 페이지에 16*1024 /(16+12) 개의 키를 저장할 수 있다.
   - ⇒ 인덱스 구성 키 값의 크기가 커지면 디스크에서 읽는 횟수가 늘어나고 느려짐. - 인덱스를 캐시해두는 버퍼 풀은 크기가 제한적이므로, 버퍼풀에 캐시할 수 있는 레코드 수도 줄어듬

2. B-Tree 깊이

   - 직접 제어할 방법은 없다.
   - 인덱스 키값의 평균 크기가 늘어나면 하나의 인덱스 페이지가 담을 수 있는 인덱스 키값의 개수가 작아짐 → depth가 깊어져서 읽기가 더 많이 필요하게 됨
   - B-Tree depth는 랜덤I/O가 몇번 일어나는지와 직결됨

3. 선택도(기수성(Cardinality))

   - 모든 인덱스 키 값 가운데 유니크한 값의 개수.

   - 높을수록 검색대상이 줄어들어 빠르다.

     - (but 정렬, 그룹핑 등을 위해 선택도가 떨어져도 인덱스 만드는게 나을수도 있음.)

     - 왜 빠른가요?

       - ex. 

         ```
         select * from test where country = 'KOREA' and city 'SEOUL';
         ```

         - 전체 데이터 10000건, country에 인덱스가 있고 위의 쿼리 실행 결과 레코드는 1개라고 가정
           - unique한 값이 10일때
             - country='KOREA'는 통계적으로 대략 10000/10=1000건 일치. 그런데 인덱스를 통해 검색된 1000개를 뒤져서 city가 seoul인걸 찾아야함..... 999건을 불필요하게 읽을 수 있음
           - unique한 값이 1000개일때
             - 10000/1000= 10건 일치. 최악의 경우에도 9건만 불필요하게 읽고 1개를 찾을 수 있다.

4. 읽어야 하는 레코드의 건수

   - 인덱스를 통해 레코드 1건 읽기 비용이 테이블에서 직접 읽는것보다 4~5배 비용이 더 듬.
   - 인덱스를 통해 읽어야할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 필터하는 방식이 효율적.

### B-Tree인덱스를 통한 데이터 읽기

- 인덱스 레인지 스캔
  - 가장 빠른 방법. 검색해야할 인덱스 범위가 결정됐을 때 사용.
  - 시작해야할 위치를 리프노드까지 찾아 들어가서 거기서부터 멈출 위치까지 리프노드 레코드만 순서대로 읽는다(스캔)  - 리프노드끼리는 linkedlist
  - 인덱스 리프 노드에서 검색 조건에 일치하는 건들 중 인덱스만 읽어서는 원하는 컬럼을 다 못가져오면 데이터 파일에서 레코드를 읽어오는 과정이 필요.
    - 레코드 한건 한건 단위로 랜덤 I/O가 발생되므로 비용이 많이 드는 것임
    - *연관된 이야기:  https://velog.io/@giantim/3 (select할때 \* 말고 필요한 필드만 써야하는 이유)*
- 인덱스 풀스캔
  - 처음부터 끝까지 다 읽는다
  - 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아닌 경우 풀스캔을 하게 됨.
    - ex. 인덱스 (A,B,C)인데 쿼리 조건절에는 B = '' 이런거
  - 쿼리가 인덱스에 명시된 컬럼만으로 조건을 처리할 수 있는 경우에 사용됨. 인덱스 뿐만아니라 데이터 레코드까지 다 읽어야하는 경우엔 이 방식으로 처리 안됨.
  - 인덱스 레인지스캔보다는 느리지만 테이블 풀스캔보다는 빠르다. 그러나 그닥 효율적이지 못하고 인덱스 풀스캔 방법을 쓰려고 인덱스를 생성하진 않음
- 루스(loose) 인덱스 스캔
  - 느슨하게, 듬성듬성하게 인덱스를 읽는 방식
  - 레인지스캔과 비슷하지만, 중간마다 필요치 않은 인덱스 키값은 skip하고 다음으로 넘어감.
  - 일반적으로  group by, 집합 함수 가운데 max(), min() 에 대해 최적화 하는 경우 사용.
  - (→ 6장에서 조건 더 자세히)

### 다중컬럼 인덱스(Concatenated index)

- 인덱스의 두번째 컬럼은 첫번재 컬럼에 의존해서 정렬되어있다.
  - 두번째 컬럼의 정렬은 첫번째 컬럼이 똑같은 레코드에서만 의미가 있음!
  - 두번째 컬럼이 정렬 순서가 빨라도 첫번째 컬럼의 순서가 늦다면 인덱스의 뒤쪽에 위치함.

### B-Tree 인덱스의 정렬 및 스캔방향

- 인덱스를 어느방향으로 읽을지는 쿼리에 따라 옵티마이저가 만들어내는 실행계획에 따라 결정된다.
- 인덱스 생성 시점에 컬럼 정렬을 asc로할지 desc로 할지 설정할 수 있음.
  - 다중컬럼인덱스일 때 컬럼 둘다 asc로하든 desc로하든 해야함.. 섞어서 쓸순 없음 :(
    - 진짜로 필요하다면 음수로 저장하는 식으로 데이터 자체를 역순 저장
- 스캔 방향
  - 옵티마이저가 상황에 따라 인덱스를 역순으로 읽기도 함.

### B-Tree 인덱스의 가용성과 효율성

- 비교조건의 종류와 효율성

  - ex. 

    ```
    select * from dept_emp where dept_no='d002' and emp_no>=1011
    ```

    - `dept_no='d002' and emp_no>=1011인 레코드를 찾고 (작업 범위 결정 조건)`
    - `dept_no='d002'인 레코드만 필터한다(필터링 조건`)
    - 인덱스가 (dept_no, emp_no)일때는 처음 찾은 레코드에서 dept_no가 d002가 아닌게 나올때까지 쭉 읽으면 됨
    - 인덱스가 (emp_no, dept_no)일때는 건건이 모든 레코드를 'd002'가 아닌지 비교. dept_no컬럼이 비교작업 범위를 좁히는데 도움을 주지 못함

- 인덱스의 가용성

  - 왼쪽 값 기준으로 정렬이기 때문에 `LIKE '%mer'` 같은건 레인지스캔 x

- 인덱스를 사용할 수 없는 조건들!

  - not equal로 비교 ("<>", "NOT IN", "NOT BETWEEN", "IS NOT NULL")
  - like '%??'  ('%승%' 이런거 포함)
  - stored function이나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 경우
  - not-deterministic 속성의 stored함수가 비교 조건에 사용된 경우(11장)
  - 데이터 타입이 서로 다른 비교(변환이 일어나기 때문)
  - 문자열 데이터 타입의 collation이 다른 경우

- mysql에서는 NULL값도 인덱스로 관리됨. 그래서 `where column is NULL` 이것도 작업 범위 결정 조건으로 인덱스를 사용함.

- 다중컬럼 인덱스 조건

  - index idx_test (column1, column2, column3, .. columnN)
  - 인덱스 사용x:  column1에 대한 조건이 없거나, column1의 비교조건이 인덱스 사용 불가 조건 중 하나
  - 작업범위 결정 조건으로 인덱스 사용o :
    1. column1~ column(i-1)까지 Equal형태( = 또는 in)로 비교
    2. column(i)에 대해 다음 연산자 중 하나로 비교
       - Equal
       - 부등호
       - like 'something%'

## 해시 인덱스

- b-tree X, hash function의 결과를 키, 레코드 주소를 value로 하는 버켓들이 있는 자료구조를 쓴다.
- 키값 충돌이 없으면 단번에 실제 레코드 저장 위치를 알 수 있다.
- 원본 키 값이 변형되어 저장되므로, 범위 검색이나 기본값 기준 정렬 등등이 안됨

## 클러스터링 인덱스

인덱스 알고리즘이라기보다 테이블 레코드의 저장방식으로 볼 수 있음.

- 테이블의 PK가 비슷한 레코드끼리 묶여서 저장되는 것을 클러스터링 인덱스라고 한다.
- pk값에 의해 레코드 저장 위치가 결정됨 = pk값이 변경되면 그 레코드의 물리적 저장 위치도 바뀌어야함
- innoDB는 항상 클러스터링 인덱스로 저장.
  - pk기반 검색이 빠른 대신 record저장이나 pk 변경이 느림
- 클러스터링 인덱스의 leaf 노드에는 레코드의 모든 컬럼이 같이 저장되어있음. (!)
- PK가 없는 경우 not null unique index의 첫번째 인덱스, 이것도 없으면 내부적으로 unique하게 증가되는 컬럼을 추가해서 클러스터 키로 선택.
  - → 후자로 가게되면 인덱스 의미가 없어짐... PK를 명시하자!!
- InnoDB 테이블에서 보조인덱스는 해당 레코드의 주소가 아니라 PK값을 저장. → PK값을 이용해 다시 한번 테이블을 검색해 최종 레코드를 가져오게된다. (MyISAM에서는 인덱스가 레코드 주소를 들고있음)
  - 테이블의 모든 보조인덱스가 PK를 갖고 있어서 인덱스만으로 처리될 수 있는 경우가 많음(커버링 인덱스)

### 주의사항

- 모든 보조인덱스가 PK를 드고있다 → PK 크기가 커지면 보조인덱스 크기도 커진다
- PK로 검색하는 경우 클러스터 되지 않은 테이블에 비해 매우 빠르게 처리될수 있음
- PK를 꼭 명시하라 auto increment라도

## Unique index 제약조건

- 유일성이 꼭 필요할 때만 쓰자.
- 성능
  - 읽기 : 차이는 거의 미미
  - 쓰기 : 중복된 값이 있는지 확인 한 후 쓰기를 해야하므로 다른 보조인덱스보다 느리다
    - - 중복체크 때문에 다른 인덱스처럼 인서트 버퍼를 쓰지 못함
- 주의사항
  - 유니크 인덱스와 일반 인덱스를 중복해서 생성할 필요 없음.

## 외래키

(4장 하고 돌아올것)

** 어느 인덱스를 쓸건지 이런걸 설정을 따로 할 수 있는것인가 아니면 스토리지 엔진에 따른 고정인가??  → 고정!!

- innoDB : B-Tree
- Memory: B-Tree, hash
- ...