## 6.1. 개요

### 실행계획이란

옵티마이저가 쿼리를 최적으로 실행하기 위해

각 테이블 데이터가 어떤 분포롤 저장돼있는지 통계 정보를 참조해서

기본 데이터를 비교해 최적의 실행계획을 수립한다

### 쿼리 실행 절차

1. SQL문장을 쪼개서 Mysql서버가 이해할 수 있는 수준으로 분리 (= SQL 파싱)
2. SQL의 파스트리 확인하면서 어떤 테이블부터 읽고 어떤 인덱스를 이용해 읽을지 선택(=최적화 및 실행계획 수립 by optimizer)
3. 2단계에서 선택된 순서,인덱스로 스토리지 엔진으로부터 데이터를 가져온다

### 옵티마이저 종류

- mysql을 포함한 대부분 rdbms가 비용기반 옵티마이저(cost-based optimizer) 를 채택함.
  - 쿼리 처리를 위한 여러가지 가능한 방법을 만들고, 각 단위 작업의 비용정보와 대상 테이블의 예측된 통계 정보를 이용해 실행계획별 비용을 산출.
- 지금은 거의 안쓰이는 규칙기반 최적화도 있음(옵티마이저 내장 우선순위에 따라 실행계획 수립. 테이블의 레코드 건수, 컬럼값 분포도 등 통계정보 사용 x)

### 통계정보

- 대략의 레코드 건수, 인덱스의 유니크한 값 개수 등.
- 레코드 건수가 적으면 통계정보가 상당히 부정확. analyze 명령으로 강제로 갱신해야할 때도 있다
  - analyze명령: 인덱스 키 값의 분포도(선택도)를 업데이트 함
- 통계정보 수집할땐 랜덤하게 인덱스 페이지 8개 또는 innodb_stats_sample_pages 파라미터 값만큼만 읽어서 수집. (다읽는게 아님ㅋㅋ)

## 6.2. 실행계획 분석

- update, insert, delete는 실행계획을 확인할 방법이 없다. where만 같은 select를 만들던지..

### 실행계획에 표시되는 각 칼럼

- id 칼럼

  - select문 당 각각 다른 id.

- select_type 칼럼

  - SIMPLE - 서브쿼리 등 없는 단순 select
  - PRIMARY - union이나 서브쿼리가 포함된 select에서 제일 바깥쪽 쿼리
  - UNION
  - DEPENDENT UNION
  - UNION RESULT
  - SUBQUERY - from절 이외에서 사용되는 서브쿼리
  - DEPENDENT SUBQUERY - 서브쿼리가 바깥쪽 select에서 정의된 칼럼을 사용하는 경우.
    - 외부 쿼리 먼저 → 서브쿼리 실행.  속도가 느리다
  - DERIVED - 서브쿼리가 from절에 사용된 경우.
  - UNCACHEABLE SUBQUERY
  - UNCACHEABLE UNION

- table 칼럼

  - 실행계획은 단위select쿼리 기준이 아닌, 테이블 기준으로 표시됨.
  - < >로 꺽쇠 안에 있는 <derived>나 <union> 같은건 임시테이블을 의미. <derived2>는 id 2번인 실행계획으로부터 만들어진 파생 테이블.
  - 같은 id라면 윗 라인이 드라이빙 테이블. 드라이빙 테이블을 먼저 읽어서 드리븐 테이블을 조인한다.

- type 칼럼

  - mysql서버가 각 테이블의 레코드를 어떤 방식으로 읽었는지

  - mysql manual에서는 'join type'이라고 소개되어있음

  - 어떤 값이 올 수 있는가

    - const

       : unique index 스캔. PK 키나 유니크 키 칼럼을 이용하는 where절로 반드시 1건을 반환하는 쿼리 처리방식 (select * from emp where id = 1)

      - 다중칼럼으로 된 키 → const를 못씀. pk의 일부만 조건일때는 ref로 표시됨
      - 옵티마이저에 의해 최적화 시 상수화된 후 (쿼리의 결과 자체를 상수화함) 쿼리 실행기로 전달하므로 const란 이름이.

    - **eq_ref:**  join을 쓰는 쿼리일때. 처음 읽은 테이블의 컬럼 값이 그 다음 테이블의 PK나 unique 키와 동등 비교 (select * from de, e where e.e_pk = de.empno;)

    - ref

       : join과 상관없이, 제약조건 없이 동등 조건으로 검색 (select * from e where d = '1';)

      - 결과가 꼭 1건이 아니어도 됨
      - (const, eq_ref, ref 세개는 where절이 동등비교연산자여야함. 성능상 문제x. 매우 빠름)

    - fulltext

    - ref_or_null

    - **unique_subquery:** where절에 쓰이는 in (subquery) 형태의 쿼리를 위한 접근방식. 서브쿼리에서 유니크한 값만 반환할 때.

    - **index_subquery:** 위와 동일, 중복된 값을 반환할 때. 그렇지만 중복된 값을 인덱스를 이용해 제거할 수 있을 때.

    - range

      : 인덱스 레인지 스캔! 인덱스를 하나의 값이 아닌 범위로 검색할 때 (부등호, is null, between, in, like)

      - (( 인덱스를 효율적으로 쓰는 대표적인 방식. const, ref, range를 묶어서 인덱스 레인지 스캔이라고 지칭함 ))

    - index_merge

      : 2개 이상의 인덱스를 이용해 각각의 검색결과를 만들고 merge.

      - 여러 인덱스를 읽고 병합하는 과정 때문에 range보다 비효율적.
      - AND, OR일때 주로 쓰이는듯한데 연산이 복잡하게 연결되면 제대로 최적화 안된다고 함.

    - index

      : 인덱스 풀스캔. (인덱스를 처음부터 끝까지 다 읽음)

      - 비교하는 레코드 수는 풀테이블스캔과 같으나, 인덱스가 크기가 더 작아서 더 빠르게 처리되고, 인덱스가 정렬된 것의 장점을 이용할 수 있다.
      - 조건
        - (range, const, ref 방식을 못쓰는 경우) && (데이터파일 안읽고 인덱스에 포함된 칼럼만으로 처리가능 || 인덱스를 이용한 정렬이나 그룹핑이 가능한 경우)

    - **ALL** :인덱스 안쓰고 풀테이블 스캔. - 가장 비효율적

- possible keys 칼럼

  - 옵티마이저가 고려했던 인덱스 후보 목록. 무시해도 됨

- key 칼럼

  - 최종 선택된! 인덱스를 표시함.
  - index_merge를 제외하고 반드시 테이블 하나 당 하나의 인덱스만 이용가능.

- key_len

- ref

- rows

- extra

## 6.3. Mysql의 주요 처리방식