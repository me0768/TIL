## 테스트 주도 개발 책 - 켄트벡

> 내가 12살 괴짜시절에 읽었던 책이 있는데, 실제 입력 테이프를 넣었을 때 그 결과로 기대할 수 있는 출력 테이프를 미리 타이프해넣고, 실제 결과가 기대결과와 같아질 때까지 코딩하라고 제안했다.
> 

책 처음 감사의 글 에 있는 이 문장이 책에서 반복적으로 이야기하는 핵심인 듯.

> 테스트를 작성할 때는 오퍼레이션의 완벽한 인터페이스에 대해 상상해보는 것이 좋다. 우리는 지금 오퍼레이션이 외부에서 어떤 식으로 보일 지에 대한 이야기를 테스트코드에 적고 있는 것이다.
> 

### 적용할때

아마도 내가 이 책을 읽기 전 TDD를 잠시 해보며 어려웠던 이유는,

- 빨간막대 - 초록막대 - 리팩토링 이여야하는데
    - 죄악을 저질러서라도 초록막대를 보는 단계를 스킵하고 빨간막대에서 바로 좋은 설계로 초록막대로 가려고 했다.
        - → 컴파일에러 수습 + 설계(중복 제거) 를 한번에 하려고 해서 어려웠던듯.
- 켄트는 예제에서 진짜 조금씩 바꾼다. 삼각측량을 쓰기도 하고. 근데 난 이 모든걸 건너뛰고 한번에 하려고 했음
    
    > 오로지 명백한 구현만 사용하면 자신에게 완벽함을 요구하게 된다. 이것은 사람을 망연자실케 할 수 있다. 만약 당신이 작성하는 것이 테스트를 통과할 수 있는 가장 단순한 변경이 아니라면 어떨까? 만약 파트너가 훨씬 단순한 변경을 보여준다면? 당신은 실패다!  (248p.)
    > 
    
    > ‘제대로 동작하는’을 푸는 동시에, ‘깨끗한 코드’를 해결하려는 것은 한번에 하기에는 너무 많은 일일 수 있다. 그렇게 되면 우선 ‘제대로 동작하는’으로 되돌아가서 그걸 해결하고, 그 후 에 ‘깨끗한 코드’를 느긋하게 해결하도록 하라. (249p.)
    > 
    - 큼직큼직하게 해결하는걸 좋아해서, 변화를 격리해가면서 촘촘하게 작은 변경을 해가는 방식이 익숙하지 않음. ‘28장 초록 막대 패턴’ 보면서 어떻게 작게 변경하는지 참고하기
- 처음에 테스트를 짤 때도 꽤 중요한데, 있는 객체 안에서만 하진 않고 상상한 객체들끼리 인터페이스로 서로 메시지를 주고받도록 하는 테스트를 작성함.
    - ex. 여기서 Bank라는 객체를 만들어서 bank가 reduce한 결과를 검증
        
        ```kotlin
        Expression sum = five.plus(five);
        Bank bank = new Bank();
        Money reduced = bank.reduce(sum, "USD");
        assertEquals(Money.dollar(10), reduced);
        ```
        

### 3부. 패턴

- **단언(assert)우선**
    - 테스트를 작성 할 때 assert를 제일 먼저 쓰자.
    - 구현을 고려하지 않고 테스트만 짜도, 사실 여러가지 문제를 해결하는 것이다
        1. 테스트하고자 하는 기능이 어디에 속하는지. (기존 메서드? 새로운 메서드? 새로운 클래스?)
        2. 메서드 이름
        3. 올바른 결과를 어떻게 검사할것인가
        4. 이 테스트가 제안하는 또 다른 테스트?
    - ⇒ 그래서 이 중에서 assert를 먼저 쓰면서 3번.올바른 결과를 어떻게 검사할 것인가 는 해결을 먼저 하기.
- 테스팅 패턴
    - 지나치게 큰 테스트 케이스를 돌아가게 하기?
        - → 더 작은 케이스를 추가하고, 그게 실행되게 한 다음에 다시 원래 큰 테스트를 추가하라.
        - ! 그리고 왜 테스트가 그렇게 컸을지, 좀더 작게 만들 방법은 없었을지 생각해보기
